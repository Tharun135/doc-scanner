"""
Gemini-only AI suggestion system for better writing recommendations.
This module provides context-aware suggestions using Google Gemini + LangChain RAG.
Issues are detected by rule-based system, solutions generated by Gemini.
"""

import json
import re
import logging
import os
from typing import Dict, List, Optional, Any
from dotenv import load_dotenv

# Import RAG system (now the primary AI provider)
try:
    from .rag_system import get_rag_suggestion
    RAG_AVAILABLE = True
except ImportError:
    RAG_AVAILABLE = False
    logging.warning("RAG system not available - falling back to rule-based suggestions only")

# Load environment variables from .env file
load_dotenv()

logger = logging.getLogger(__name__)

class GeminiAISuggestionEngine:
    """
    AI suggestion engine using Google Gemini + LangChain RAG only.
    Issues are detected by rule-based system, solutions generated by Gemini.
    """
    
    def __init__(self):
        self.rag_available = RAG_AVAILABLE
        logger.info(f"Gemini AI Suggestion Engine initialized. RAG available: {self.rag_available}")
        
    def generate_contextual_suggestion(self, feedback_text: str, sentence_context: str = "",
                                     document_type: str = "general", 
                                     writing_goals: List[str] = None,
                                     document_content: str = "") -> Dict[str, Any]:
        """
        Generate AI suggestion using Gemini + RAG for solutions.
        Issues are already detected by rule-based system.
        
        Returns:
            Dict containing suggestion, confidence, and metadata
        """
        try:
            # Primary method: Use Gemini RAG for solution generation
            if self.rag_available:
                logger.info("Using Gemini RAG for solution generation")
                rag_result = get_rag_suggestion(
                    feedback_text=feedback_text,
                    sentence_context=sentence_context,
                    document_type=document_type,
                    document_content=document_content
                )
                
                if rag_result:
                    logger.info("Gemini RAG suggestion generated successfully")
                    return {
                        "suggestion": rag_result["suggestion"],
                        "confidence": rag_result.get("confidence", "high"),
                        "method": "gemini_rag",
                        "sources": rag_result.get("sources", []),
                        "context_used": {
                            **rag_result.get("context_used", {}),
                            "document_type": document_type,
                            "writing_goals": writing_goals,
                            "primary_ai": "gemini",
                            "issue_detection": "rule_based"
                        }
                    }
            
            # Fallback: Enhanced rule-based suggestions
            logger.info("Falling back to enhanced rule-based suggestions")
            return self.generate_smart_fallback_suggestion(feedback_text, sentence_context)
            
        except Exception as e:
            logger.error(f"Gemini suggestion failed: {str(e)}")
            # Fall back to rule-based suggestions
            return self.generate_smart_fallback_suggestion(feedback_text, sentence_context)
    
    def generate_smart_fallback_suggestion(self, feedback_text: str, 
                                         sentence_context: str = "") -> Dict[str, Any]:
        """
        Generate intelligent rule-based suggestions when Gemini is unavailable.
        Much more sophisticated than basic fallbacks.
        """
        feedback_lower = feedback_text.lower()
        context_lower = sentence_context.lower()
        
        # Check if feedback already contains a specific rewrite suggestion
        if "→ suggested:" in feedback_text.lower() or "suggested:" in feedback_text.lower():
            # Extract the suggested rewrite from the feedback
            suggested_pattern = r'suggested:\s*["\']([^"\']+)["\']'
            match = re.search(suggested_pattern, feedback_text, re.IGNORECASE)
            if match:
                suggested_text = match.group(1)
                return {
                    "suggestion": f'CORRECTED TEXT: "{suggested_text}"\nCHANGE MADE: {feedback_text.split(".")[0]}',
                    "confidence": "high",
                    "method": "rule_based_rewrite",
                    "pattern_matched": "suggested_rewrite"
                }
        
        # Check for "Original: ... → Suggested: ..." pattern
        original_suggested_pattern = r'original:\s*["\']([^"\']+)["\']\s*→\s*suggested:\s*["\']([^"\']+)["\']'
        match = re.search(original_suggested_pattern, feedback_text, re.IGNORECASE)
        if match:
            original_text = match.group(1).strip()
            suggested_text = match.group(2).strip()
            change_description = feedback_text.split(".")[0] if "." in feedback_text else "Applied suggested rewrite"
            return {
                "suggestion": f'CORRECTED TEXT: "{suggested_text}"\nCHANGE MADE: {change_description}',
                "confidence": "high", 
                "method": "rule_based_rewrite",
                "pattern_matched": "original_to_suggested"
            }
        
        # Advanced pattern matching with context awareness
        suggestions = {
            # Passive voice patterns
            ("passive", "voice"): {
                "suggestion": self._generate_active_voice_suggestion(sentence_context),
                "confidence": "medium"
            },
            
            # Sentence length and complexity
            ("long", "sentence"): {
                "suggestion": self._generate_sentence_shortening_suggestion(sentence_context),
                "confidence": "medium"
            },
            
            # Modal verb patterns
            ("may", "modal"): {
                "suggestion": self._generate_modal_verb_suggestion(sentence_context, feedback_text),
                "confidence": "high"
            },
            
            # Backup/back up patterns
            ("backup", "back up"): {
                "suggestion": self._generate_backup_suggestion(sentence_context, feedback_text),
                "confidence": "high"
            },
            
            # Word choice improvements
            ("vague", "unclear"): {
                "suggestion": "Replace vague terms with specific, concrete language. Add precise details, numbers, or examples to clarify your meaning.",
                "confidence": "medium"
            },
            
            # Readability improvements
            ("complex", "difficult"): {
                "suggestion": "Simplify complex language: use shorter words, break up long phrases, and explain technical terms. Consider your audience's expertise level.",
                "confidence": "medium"
            },
            
            # Structure and flow
            ("transition", "flow", "choppy"): {
                "suggestion": "Improve flow with transition words: 'However' (contrast), 'Therefore' (conclusion), 'Furthermore' (addition), 'Meanwhile' (time), 'In contrast' (comparison).",
                "confidence": "high"
            }
        }
        
        # Find best matching suggestion
        for patterns, suggestion_data in suggestions.items():
            if any(pattern in feedback_lower for pattern in patterns):
                return {
                    "suggestion": suggestion_data["suggestion"],
                    "confidence": suggestion_data["confidence"],
                    "method": "smart_fallback",
                    "pattern_matched": patterns
                }
        
        # Default enhanced suggestion
        return {
            "suggestion": self._generate_general_improvement_suggestion(feedback_text, sentence_context),
            "confidence": "low",
            "method": "general_fallback"
        }
    
    def _generate_active_voice_suggestion(self, sentence: str) -> str:
        """Generate specific active voice suggestions with actual rewrite."""
        if not sentence:
            return "Convert passive voice to active voice: identify who performs the action and make them the subject."
        
        # Try to actually convert the sentence to active voice
        active_version = self._convert_passive_to_active(sentence)
        if active_version and active_version != sentence:
            return f'CORRECTED TEXT: "{active_version}"\nCHANGE MADE: Converted passive voice to active voice'
        
        # If automatic conversion fails, provide specific guidance
        return "Rewrite in active voice: move the action performer to the beginning and make them the subject."
    
    def _convert_passive_to_active(self, sentence: str) -> str:
        """Attempt to convert passive voice to active voice."""
        if not sentence:
            return sentence
        
        # Simple passive voice patterns
        passive_patterns = [
            (r'(\w+)\s+was\s+(\w+ed)\s+by\s+(.+)', r'\3 \2 \1'),
            (r'(\w+)\s+were\s+(\w+ed)\s+by\s+(.+)', r'\3 \2 \1'),
            (r'(\w+)\s+is\s+being\s+(\w+ed)\s+by\s+(.+)', r'\3 \2 \1'),
            (r'(\w+)\s+are\s+being\s+(\w+ed)\s+by\s+(.+)', r'\3 \2 \1'),
        ]
        
        for pattern, replacement in passive_patterns:
            match = re.search(pattern, sentence, re.IGNORECASE)
            if match:
                # Simple conversion attempt
                try:
                    return re.sub(pattern, replacement, sentence, flags=re.IGNORECASE)
                except:
                    continue
        
        return sentence
    
    def _generate_sentence_shortening_suggestion(self, sentence: str) -> str:
        """Generate specific suggestions for shortening sentences."""
        if not sentence:
            return "Break long sentences into shorter ones. Aim for 15-20 words per sentence for better readability."
        
        word_count = len(sentence.split())
        if word_count > 25:
            return f'SUGGESTION: This sentence has {word_count} words. Break it into 2-3 shorter sentences. Look for conjunctions (and, but, or, because) as natural break points.\nCHANGE MADE: Identify main ideas and separate them with periods instead of commas or conjunctions.'
        
        return "Break this into shorter sentences. Look for natural break points at conjunctions or dependent clauses."
    
    def _generate_modal_verb_suggestion(self, sentence: str, feedback: str) -> str:
        """Generate specific modal verb suggestions."""
        if not sentence:
            return "Use appropriate modal verbs: 'can' for ability/permission, 'should' for recommendations, 'must' for requirements."
        
        feedback_lower = feedback.lower()
        
        if "may" in feedback_lower and "permission" in feedback_lower:
            rewritten = re.sub(r'\bmay\b', 'can', sentence, flags=re.IGNORECASE)
            return f'CORRECTED TEXT: "{rewritten}"\nCHANGE MADE: Replaced "may" with "can" for permission context'
        
        return "Review modal verb usage: use 'can' for ability/permission, 'may' for possibility, 'should' for recommendations."
    
    def _generate_backup_suggestion(self, sentence: str, feedback: str) -> str:
        """Generate specific backup/back up suggestions."""
        if not sentence:
            return "Use 'backup' as noun/adjective (backup files) or 'back up' as verb (back up your files)."
        
        feedback_lower = feedback.lower()
        context_lower = sentence.lower()
        
        # Check if "backup" is used correctly as a noun/adjective
        noun_patterns = [
            r'\bbackup\s+(files?|data|documents?|system|solution|strategy|process|operation)\b',
            r'\b(create|make|have|support|provide|include)\s+backup\b',
        ]
        
        verb_patterns = [
            r'\b(to\s+)?backup\s+(your|the|all|important)\b',
            r'\b(please|should|must|will)\s+backup\b',
            r'\byou\s+backup\b',
        ]
        
        for pattern in verb_patterns:
            if re.search(pattern, context_lower):
                rewritten = re.sub(r'\bbackup\b', 'back up', sentence, flags=re.IGNORECASE)
                return f'CORRECTED TEXT: "{rewritten}"\nCHANGE MADE: Changed "backup" to "back up" (verb form)'
        
        # If no specific pattern matches, provide general guidance
        return f'CORRECTED TEXT: "{sentence}"\nCHANGE MADE: Context unclear - use "backup" as noun/adjective ("backup files") or "back up" as verb ("back up your files")'
    
    def _generate_general_improvement_suggestion(self, feedback: str, context: str) -> str:
        """Generate specific, actionable solutions based on the feedback and context."""
        feedback_lower = feedback.lower()
        
        # Grammar and style improvements
        if "grammar" in feedback_lower:
            return "Check subject-verb agreement, verb tenses, and sentence structure. Consider using a grammar checker for detailed analysis."
        
        elif "spelling" in feedback_lower:
            return "Review spelling carefully. Use spell-check tools and consider creating a personal dictionary for technical terms."
        
        elif "punctuation" in feedback_lower:
            return "Review punctuation rules: use commas for lists and clauses, periods for complete thoughts, semicolons for related independent clauses."
        
        elif "capitalization" in feedback_lower:
            return "Capitalize proper nouns, the first word of sentences, and titles. Use lowercase for common nouns and articles."
        
        elif "wordiness" in feedback_lower or "concise" in feedback_lower:
            return "Remove unnecessary words and phrases. Replace weak verb + noun combinations with strong verbs (e.g., 'make a decision' → 'decide')."
        
        # Default suggestion
        return f"Review and improve this text based on the issue: {feedback}. Consider clarity, conciseness, and correctness."


# Global instance for easy use
ai_engine = GeminiAISuggestionEngine()

def get_enhanced_ai_suggestion(feedback_text: str, sentence_context: str = "",
                             document_type: str = "general", 
                             writing_goals: List[str] = None,
                             document_content: str = "") -> Dict[str, Any]:
    """
    Convenience function to get Gemini-enhanced AI suggestions.
    
    Args:
        feedback_text: The feedback or issue identified by rules
        sentence_context: The actual sentence or text
        document_type: Type of document (technical, marketing, academic, etc.)
        writing_goals: List of writing goals (clarity, conciseness, etc.)
        document_content: Full document content for RAG context (optional)
    
    Returns:
        Dictionary with suggestion and metadata
    """
    return ai_engine.generate_contextual_suggestion(
        feedback_text, sentence_context, document_type, writing_goals, document_content
    )
